
# 1. 递归
```java
public class Solution1 {
    public boolean isMatch(String s, String p) {
        // 下面这句就没有必要了
//        if(s.length() == 0 && p.length() == 0)return true;
        if (p.length() == 0) return s.length() == 0;
        boolean firstMatch = !s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.');
        // ‘*’对前一个字符的影响有：0个，1个，多个，分析一下可知0个与多个的可以拼凑出1个的情况，所以只需要判断这两种情况
        // 三种情况都写的话，会超时
        if (p.length() >= 2 && p.charAt(1) == '*') {
            return isMatch(s, p.substring(2)) || (firstMatch && isMatch(s.substring(1), p));
        } else {
            return firstMatch && isMatch(s.substring(1), p.substring(1));
        }
    }
}
```

# 2. 动态规划-自底向上
```java
public class Solution2 {
    /**
     * 动态规划，从后往前（自底向上）
     * @param s
     * @param p
     * @return
     */
    public boolean isMatch(String s, String p) {
        int m = s.length(),n = p.length();
        Boolean[][] dp = new Boolean[m+1][n+1];
        dp[m][n] = true;
        for (int i = m; i >=0; i--) {
            for (int j = n-1; j >=0 ; j--) {
                // 这一句后面的判断没有加括号，导致失败
                //boolean firstMatch = i < s.length() && s.charAt(i) == p.charAt(j) || p.charAt(j) == '.';
                boolean firstMatch = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');
                if (j + 1 < p.length() && p.charAt(j + 1) == '*') {
                    dp[i][j] = dp[i][j+2] || firstMatch && dp[i+1][j];
                }else
                    dp[i][j] = firstMatch && dp[i+1][j+1];
            }
        }
        return dp[0][0];
    }
}
```

# 3. 动态规划自顶向下

```java
public class Solution3 {
    /**
     * 动态规划 从前往后（自顶向下）
     * 完全是递归思路+memeo
     * @param text
     * @param pattern
     * @return
     */
    public boolean isMatch(String text, String pattern) {
        Boolean[][] memo = new Boolean[text.length() + 1][pattern.length() + 1];
        return dp(memo,0, 0, text, pattern);
    }

    private boolean dp(Boolean[][] memo, int i, int j, String text, String pattern) {
        if(memo[i][j]!=null)return memo[i][j];

        boolean ret = false;
        if (j == pattern.length())return i == text.length();
        boolean firstMatch = i < text.length() && (text.charAt(i) == pattern.charAt(j) || pattern.charAt(j) == '.');
        if (j < pattern.length() - 1 && pattern.charAt(j + 1) == '*') {
            ret = dp(memo, i, j + 2, text, pattern) || (firstMatch && dp(memo, i + 1, j, text, pattern));
        } else {
            ret = firstMatch && dp(memo, i + 1, j + 1, text, pattern);
        }
        memo[i][j] = ret;
        return ret;
    }
}
```