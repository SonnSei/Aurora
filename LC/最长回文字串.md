# 1. 中心扩展发
```java
public class Solution1 {
    /**
     * 中心扩展法
     * @param s
     * @return
     */
    public String longestPalindrome(String s) {
        if(s == null || s.length() == 0)return "";
        int max = 0;
        int begin = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expand(s,i,i);
            int len2 = expand(s,i,i+1);
            int len= Math.max(len1,len2);
            if(len>max){
                max = len;
                begin = i-(len-1)/2;
            }
        }
        return s.substring(begin,begin+max);
    }

    private int expand(String s, int l, int r){
        while(l>=0 && r< s.length() && s.charAt(l)==s.charAt(r)){
            l--;r++;
        }
        return r-l-1;
    }
}
```

# 2. Manacher's Algorithm

```java
public class Solution2 {
    public String longestPalindrome(String s) {
        if(s == null || s.length() == 0)return "";
        List<Character> list = new ArrayList<>(s.length()*2+1);
        for (int i = 0; i < s.length(); i++) {
            list.add('#');
            list.add(s.charAt(i));
        }
        list.add('#');

        int maxMid=0,maxRight = 0;
        int retMid = 0,maxRadius = 0;

        // 这里不要写成s.length()
        int[] dp = new int[list.size()];

        for (int i = 0; i < list.size(); i++) {
            dp[i] = maxRight>i?Math.min(dp[maxMid*2-i],maxRight-i):1;
            while((i-dp[i])>=0 &&(i+dp[i])<list.size() && list.get(i+dp[i])==list.get(i-dp[i]))
                dp[i]++;
            if (dp[i] > maxRadius) {
                maxRadius = dp[i];
                retMid = i;
            }
            if ((i + dp[i]) > maxRight) {
                maxRight = i + dp[i];
                maxMid = i;
            }
        }
        StringBuilder ret = new StringBuilder();
        for (int i = retMid-maxRadius+1; i <retMid+maxRadius ; i++) {
            char c = list.get(i);
            if(c!='#') ret.append(c);
        }
        return ret.toString();
    }
}
```